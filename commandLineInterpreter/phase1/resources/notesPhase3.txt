-----QUESTION TO ASK
do we have to play for SIC/XE instructions now?
	IF SO (check ppt 5 for detailed additions)
-check if the label that we want to address... is a valid label...
-check if the label that we want to address... exists...
-handle operand of END... which idk what it is...
-handle operand of START... which is the name of the program...
-hanlde ,x from buffer

---assumptions
-we dont need to check a lines Label (that was handled in pass1)
-check every lines operation
	-IF directive the operand has been handled already
	-ELSE mnemonic the operand has to be handled now
-we assume all mnemonics have an operand of form "OPERAND" or "OPERAND,X"
	-except RSUB which has no operand
	-OPERAND might be (1) a label (2) a HEX address

-for mnemonics we need to 
	-grab the opcode of the operation and add it to the object code
	-make sure the label exist and grab its value to create the object code
-for directives
	-START, END, RESW, and RESB have no object code
	-BYTE 
		-C convert string to hex rep
		-X 
	-WORD read in operand... convert to hex... and simply buffer it infront with 0s (max length of 6 in total)

called immediately after pass 1

intermediate file + symbol table + opcode table
->
object file and listing file

---object file (ready to be loaded by the load proc)
-specs?

---listing file
//for every line
source line (with comments)
generated object code
load address of the statement
error messages
//at end
a listing of the symbol table 

NOTE: the object file should not be generated if an error is found

Deliverables
1. a documented source listing
2. two listing of assembler language source files (one with errors, one with no errors)
3. a copy of the listing file and the object files generated for both
4. a copy of this should be in the 3334/phase3 directory

/*
OPCODE (from reading operation)[8] | INDEX BIT (from reading op)[1] | ADDRESS (from RETADR)[15]
3 record types (1)Header[once] (2)Text[multiple times until limit ???] (3)End[once]
for header record NAME(6) | LOAD ADDRESS(6) | LENGTH(6)
for text record ADDRESS(6) | SIZE (2) | INSTRUCT/DATA (<= 60)

if ',x' set index bit
strip off ',x'
look up operand in symbol table
get address


-----PSUEDOCODE
read first input line from intermediate file
if OPCODE = ‘START’ then
{  
	write listing line
	read next input line 
}
write header record to object file
initialize first text record
while OPCODE != ‘END’ do
{  
	if this is not a comment line then
	//---
	search OPTAB for OPCODE
	if found then
	{  
		if there is a symbol in OPERAND field then
		{  
			search SYMTAB for OPERAND
		   if found then
				store symbol value as operand address
		    else 
				store 0 as operand address
				set error flag (undefined symbol)
		}
	    else if OPCODE = ‘BYTE’ or ‘WORD’ then
			convert constant to object code
	}
	if object code will not fit into current text record then
	{  
		write text record to object file
	    initialize new text record 
    }
	add object code to text record
	//---
   	write listing line
   	read next input line 
}
write last text record to object file
write end record to object file
write last listing line

---------------THINGS TO WATCH OUT FOR---------------

OPERATION SPECIFIC-----

//ONLY when generating object file
900 -> program length above 32768 byte limit 
//anytime we are printing the LOCCTR
910 -> LOCCTR is too big and should be smaller than (FFFF) base 16 (***READ BY PASS 2)

CHECK
//line 128 result
//line 224 D vs F
//why cant i close the file
*/